# =========================
# FILE: agent/label_loader.py
# =========================
"""
App label loading system with multiple sources:
1. Disk cache (app_label_cache.json) - instant, persistent
2. Extracted labels (app_labels_map.txt) - APK-extracted real names (highest priority)
3. Auto-extraction via aapt2 - for newly installed apps
4. Batch dumpsys - catches apps with nonLocalizedLabel set
5. Package name fallback - last resort

IMPORTANT: This file is separate from apps.py to protect the latency fix.
Do NOT merge this into apps.py.
"""

import json
import os
import re
import subprocess
import shutil
import tempfile
import platform
from typing import Dict, Optional, Set, List
from datetime import datetime


# File paths
LABEL_CACHE_FILE = "app_label_cache.json"
EXTRACTED_LABELS_FILE = "app_labels_map.txt"

# aapt2 path detection
AAPT2_SEARCH_PATHS = [
    # Common Windows SDK locations
    os.path.expanduser(r"~\AppData\Local\Android\Sdk\build-tools"),
    r"C:\Android\Sdk\build-tools",
    # Common Linux/Mac SDK locations
    os.path.expanduser("~/Android/Sdk/build-tools"),
    os.path.expanduser("~/Library/Android/sdk/build-tools"),
]


class LabelLoader:
    """
    Manages app label loading from multiple sources with priority:
    1. Extracted labels (app_labels_map.txt) - HIGHEST priority
    2. Auto-extracted via aapt2 (for new apps)
    3. Disk cache (app_label_cache.json)
    4. Batch dumpsys output
    5. Package name fallback - LOWEST priority
    """

    def __init__(self, adb=None) -> None:
        self.adb = adb
        self.label_cache: Dict[str, str] = {}
        self.extracted_labels: Dict[str, str] = {}
        self.cache_file = LABEL_CACHE_FILE
        self.extracted_file = EXTRACTED_LABELS_FILE
        self.aapt2_path: Optional[str] = None
        self._detect_aapt2()

    # ==========================================================
    # AAPT2 DETECTION
    # ==========================================================
    def _detect_aapt2(self) -> None:
        """Find aapt2 in Android SDK build-tools."""
        # Check if aapt2 is in PATH
        aapt2_in_path = shutil.which("aapt2")
        if aapt2_in_path:
            self.aapt2_path = aapt2_in_path
            return

        # Search known SDK locations
        for base_path in AAPT2_SEARCH_PATHS:
            if not os.path.exists(base_path):
                continue

            # Find latest build-tools version
            try:
                versions = sorted(os.listdir(base_path), reverse=True)
                for version in versions:
                    if platform.system() == "Windows":
                        candidate = os.path.join(base_path, version, "aapt2.exe")
                    else:
                        candidate = os.path.join(base_path, version, "aapt2")

                    if os.path.exists(candidate):
                        self.aapt2_path = candidate
                        return
            except Exception:
                continue

    # ==========================================================
    # SOURCE 1: Extracted labels (app_labels_map.txt)
    # ==========================================================
    def load_extracted_labels(self) -> int:
        """
        Load labels from app_labels_map.txt (generated by PS1/aapt2).
        Format: Label=Package (one per line, first line is header)
        
        Returns:
            Number of labels loaded
        """
        self.extracted_labels = {}

        if not os.path.exists(self.extracted_file):
            return 0

        try:
            with open(self.extracted_file, "r", encoding="utf-8") as f:
                lines = f.readlines()

            for line in lines:
                line = line.strip()
                if not line:
                    continue

                # Skip header
                if line == "Label=Package":
                    continue

                # Skip failed entries
                if line.startswith("pull_failed=") or line.startswith("no_label="):
                    continue

                # Parse "Label=Package"
                eq_idx = line.find("=")
                if eq_idx < 1:
                    continue

                label = line[:eq_idx].strip()
                package = line[eq_idx + 1:].strip()

                if label and package:
                    self.extracted_labels[package] = label

            return len(self.extracted_labels)

        except Exception as e:
            print(f"‚ö†Ô∏è Could not load extracted labels: {e}")
            return 0

    # ==========================================================
    # SOURCE 2: Auto-extraction via aapt2 (for new apps)
    # ==========================================================
    def auto_extract_labels(self, packages: Set[str]) -> Dict[str, str]:
        """
        Automatically extract labels for given packages using aapt2.
        Pulls APK from device ‚Üí runs aapt2 dump badging ‚Üí parses label.
        
        This runs ONLY for new apps not covered by app_labels_map.txt.
        
        Args:
            packages: Set of package names to extract labels for
        
        Returns:
            Dict of package -> label
        """
        if not self.aapt2_path:
            return {}

        if not self.adb:
            return {}

        if not packages:
            return {}

        labels = {}
        tmp_dir = os.path.join(tempfile.gettempdir(), "chiru_apk_extract")
        os.makedirs(tmp_dir, exist_ok=True)

        print(f"üîß Auto-extracting labels for {len(packages)} new app(s) via aapt2...")

        for pkg in packages:
            try:
                # Get APK path on device
                apk_path_output = self.adb.run(["shell", "pm", "path", pkg])
                # Output: "package:/data/app/.../base.apk"
                apk_path = apk_path_output.replace("package:", "").strip()

                if not apk_path:
                    continue

                # Pull APK to temp
                local_apk = os.path.join(tmp_dir, f"{pkg}.apk")

                if not os.path.exists(local_apk):
                    self.adb.run(["pull", apk_path, local_apk])

                # Run aapt2 dump badging
                result = subprocess.run(
                    [self.aapt2_path, "dump", "badging", local_apk],
                    capture_output=True, text=True, timeout=10
                )

                if result.returncode != 0:
                    continue

                # Parse application-label
                for line in result.stdout.splitlines():
                    if line.startswith("application-label:"):
                        label = line.replace("application-label:", "").strip().strip("'\"")
                        if label:
                            labels[pkg] = label
                            break

            except Exception as e:
                # Silently skip failed extractions
                continue

        # Append newly extracted labels to app_labels_map.txt
        if labels:
            self._append_to_extracted_file(labels)
            print(f"   ‚úÖ Extracted {len(labels)} new label(s)")

        # Cleanup temp APKs
        try:
            for f in os.listdir(tmp_dir):
                os.remove(os.path.join(tmp_dir, f))
        except Exception:
            pass

        return labels

    def _append_to_extracted_file(self, new_labels: Dict[str, str]) -> None:
        """Append newly extracted labels to app_labels_map.txt."""
        try:
            # Create file with header if it doesn't exist
            if not os.path.exists(self.extracted_file):
                with open(self.extracted_file, "w", encoding="utf-8") as f:
                    f.write("Label=Package\n")

            with open(self.extracted_file, "a", encoding="utf-8") as f:
                for pkg, label in new_labels.items():
                    f.write(f"{label}={pkg}\n")

        except Exception as e:
            print(f"‚ö†Ô∏è Could not append to {self.extracted_file}: {e}")

    # ==========================================================
    # SOURCE 3: Disk cache (app_label_cache.json)
    # ==========================================================
    def load_disk_cache(self) -> int:
        """Load label cache from disk."""
        if not os.path.exists(self.cache_file):
            self.label_cache = {}
            return 0

        try:
            with open(self.cache_file, "r", encoding="utf-8") as f:
                data = json.load(f)
                self.label_cache = data.get("labels", {})
                return len(self.label_cache)
        except Exception as e:
            print(f"‚ö†Ô∏è Could not load label cache: {e}")
            self.label_cache = {}
            return 0

    def save_disk_cache(self) -> None:
        """Save merged label cache to disk."""
        try:
            data = {
                "labels": self.label_cache,
                "last_updated": datetime.now().isoformat(),
                "count": len(self.label_cache),
            }
            with open(self.cache_file, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"‚ö†Ô∏è Could not save label cache: {e}")

    # ==========================================================
    # SOURCE 4: Batch dumpsys parsing
    # ==========================================================
    def batch_fetch_from_dumpsys(self, target_packages: Set[str] = None) -> Dict[str, str]:
        """
        Fetch labels via single 'dumpsys package' call.
        Only returns labels for apps that have nonLocalizedLabel set.
        """
        if not self.adb:
            return {}

        labels = {}

        try:
            print("üîç Running batch dumpsys...")
            raw_output = self.adb.run(["shell", "dumpsys", "package"])

            current_pkg = None

            for line in raw_output.splitlines():
                line = line.strip()

                pkg_match = re.match(r'Package\s+\[([^\]]+)\]', line)
                if pkg_match:
                    current_pkg = pkg_match.group(1)
                    continue

                if current_pkg:
                    label_match = re.match(
                        r'application-label(?:-[a-zA-Z-]+)?:\s*(.+)', line
                    )
                    if label_match:
                        label = label_match.group(1).strip().strip("'\"")
                        if label:
                            if target_packages is None or current_pkg in target_packages:
                                if current_pkg not in labels:
                                    labels[current_pkg] = label

        except Exception as e:
            print(f"‚ö†Ô∏è Batch dumpsys failed: {e}")

        return labels

    # ==========================================================
    # SOURCE 5: Package name fallback
    # ==========================================================
    @staticmethod
    def label_from_package_name(pkg: str) -> str:
        """Last resort: generate readable label from package name."""
        return (
            pkg.split(".")[-1]
            .replace("-", " ")
            .replace("_", " ")
            .title()
        )

    # ==========================================================
    # MERGED INITIALIZATION
    # ==========================================================
    def initialize(self, current_packages: Set[str]) -> Dict[str, str]:
        """
        Build complete label map using all sources with priority:
        1. Load disk cache
        2. Load extracted labels from app_labels_map.txt
        3. For uncovered apps: try auto-extraction via aapt2
        4. For still uncovered: batch dumpsys
        5. Anything remaining: package name fallback
        6. Apply priority: extracted > auto-extracted > dumpsys > cache > fallback
        7. Save merged result to disk
        
        Args:
            current_packages: Set of currently installed package names
        
        Returns:
            Complete dict of package -> label for all current packages
        """
        # Step 1: Load disk cache
        cache_count = self.load_disk_cache()
        if cache_count > 0:
            print(f"üíæ Loaded {cache_count} cached labels")

        # Step 2: Load extracted labels
        extracted_count = self.load_extracted_labels()
        if extracted_count > 0:
            print(f"üìã Loaded {extracted_count} APK-extracted labels")

        # Step 3: Find uncovered apps
        cached_set = set(self.label_cache.keys())
        extracted_set = set(self.extracted_labels.keys())
        covered = cached_set | extracted_set
        uncovered = current_packages - covered

        # Step 4: Auto-extract labels for uncovered apps (if aapt2 available)
        auto_extracted = {}
        if uncovered and self.aapt2_path:
            auto_extracted = self.auto_extract_labels(uncovered)
            # Update extracted labels with new ones
            self.extracted_labels.update(auto_extracted)
            uncovered = uncovered - set(auto_extracted.keys())

        # Step 5: Batch dumpsys for anything still uncovered
        dumpsys_labels = {}
        if uncovered:
            dumpsys_labels = self.batch_fetch_from_dumpsys(uncovered)
            uncovered = uncovered - set(dumpsys_labels.keys())

        # Step 6: Build final merged label map
        # Priority: extracted > auto-extracted > dumpsys > cache > fallback
        final_labels: Dict[str, str] = {}

        for pkg in current_packages:
            if pkg in self.extracted_labels:
                final_labels[pkg] = self.extracted_labels[pkg]
            elif pkg in dumpsys_labels:
                final_labels[pkg] = dumpsys_labels[pkg]
            elif pkg in self.label_cache:
                final_labels[pkg] = self.label_cache[pkg]
            else:
                final_labels[pkg] = self.label_from_package_name(pkg)

        # Step 7: Save merged cache
        self.label_cache = final_labels
        self.save_disk_cache()

        return final_labels

    # ==========================================================
    # UTILITIES
    # ==========================================================
    def get_missing_labels(self, current_packages: Set[str]) -> Set[str]:
        """
        Find packages that only have fallback labels (no real name).
        """
        missing = set()
        extracted_set = set(self.extracted_labels.keys())

        for pkg in current_packages:
            if pkg in extracted_set:
                continue

            label = self.label_cache.get(pkg, "")
            fallback = self.label_from_package_name(pkg)

            if label == fallback:
                missing.add(pkg)

        return missing

    def clear_cache(self) -> None:
        """Clear disk cache (for full reindex)."""
        self.label_cache = {}
        if os.path.exists(self.cache_file):
            os.remove(self.cache_file)
            print("üóëÔ∏è Label cache cleared")
